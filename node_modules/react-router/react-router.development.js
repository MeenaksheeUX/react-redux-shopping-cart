import { createMemoryHistory, parsePath } from 'history';import PropTypes from 'prop-types';import React from 'react';function k(a,b){if(!a)throw Error(b);}let l=React.createContext({history:null,location:{pathname:"/",search:"",hash:""},pending:!1});l.Consumer.displayName="Location.Consumer";l.Provider.displayName="Location.Provider";let n=React.createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});n.Consumer.displayName="Route.Consumer";n.Provider.displayName="Route.Provider";
function p(a){var {children:b,initialEntries:c,initialIndex:d,timeout:e}=a;a=React.useRef(null);null==a.current&&(a.current=createMemoryHistory({initialEntries:c,initialIndex:d}));return React.createElement(q,{children:b,history:a.current,timeout:e})}p.displayName="MemoryRouter";
p.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number};function r(a){var {to:b,replace:c=!1,state:d}=a;t()(b,{replace:c,state:d});return null}r.displayName="Navigate";
r.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function u(){return v()}u.displayName="Outlet";u.propTypes={};function w(){return null}w.displayName="Redirect";
w.propTypes={children:function(a,b){if(null!=a[b])return Error("A <Redirect> should not have child routes; they will never be rendered.")},from:PropTypes.string,to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})])};function x(a){({element:a}=a);return a}x.displayName="Route";x.propTypes={children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};let y=a=>a(),z=React.useTransition||(()=>[y,!1]);
function q(a){var {children:b=null,history:c,timeout:d=2E3}=a;let [e,g]=React.useState(c.location),[f,h]=z({timeoutMs:d});a=React.useRef(!1);React.useContext(l).history?k(!1,"You rendered a <Router> inside another <Router> but you should only ever render one in a given app."):void 0;a.current||(a.current=!0,c.listen(b=>{var {location:a}=b;f(()=>{g(a)})}));return React.createElement(l.Provider,{children:b,value:{history:c,location:e,pending:h}})}q.displayName="Router";
q.propTypes={children:PropTypes.node,history:PropTypes.shape({action:PropTypes.string,location:PropTypes.object,push:PropTypes.func,replace:PropTypes.func,go:PropTypes.func,listen:PropTypes.func,block:PropTypes.func}),timeout:PropTypes.number};
function A(a){var {basename:b="",caseSensitive:c=!1,children:d}=a;let {pathname:e,route:g}=React.useContext(n);var f=g&&g.path;a=!g||g.path.endsWith("*");f=`You rendered <Routes> at "${e}" (under route path "${f}")`+' but the route path has no trailing "*", so the child routes won\'t be able to match'+` any part of the URL. You should use route path "${f}/*" instead.`;if(!a){"undefined"!==typeof console&&console.warn(f);try{throw Error(f);}catch(h){}}a=B(d);return C(a,b,c)}A.displayName="Routes";
A.propTypes={basename:PropTypes.string,caseSensitive:PropTypes.bool,children:PropTypes.node};function B(a){let b=[];React.Children.forEach(a,a=>{if(React.isValidElement(a)){var {children:c,from:e,path:g,to:f}=a.props;if(a.type===React.Fragment)b.push.apply(b,B(c));else{g=g||e||"/";if(f)a={path:g,redirectTo:f};else{a={path:g,element:a};let b=B(c);b.length&&(a.children=b)}b.push(a)}}});return b}function D(){return React.useContext(l).location}
function t(){let {history:a,pending:b}=React.useContext(l),{pathname:c}=React.useContext(n);null==a?k(!1,"navigation may be used only in the context of a <Router> component"):void 0;return React.useCallback((d,e)=>{var {replace:g,state:f}=void 0===e?{}:e;"number"===typeof d?a.go(d):(d=E(d,c),a[g||b?"replace":"push"](d,f))},[a,b,c])}function v(){return React.useContext(n).outlet}function F(a){let {pathname:b}=React.useContext(n);return React.useMemo(()=>E(a,b),[a,b])}
function C(a,b,c){b=void 0===b?"":b;c=void 0===c?!1:c;let d=D(),e=t(),{params:g,pathname:f}=React.useContext(n);b=b?[f,b].join("/").replace(/\/\/+/g,"/"):f;var h=React.useMemo(()=>G(a,d,b,c),[a,d,b,c]);if(!h)return null;var m=h.find(a=>null!=a.route.redirectTo);if(m){let {params:a,route:b}=m;h=E(b.redirectTo,f);({pathname:m}=h);/:\w+/.test(m)&&(h=Object.assign({},h,{pathname:H(m,a)}));e(h,{replace:!0});return null}return h.reduceRight((a,c)=>{var {params:d,pathname:e,route:f}=c;return React.createElement(n.Provider,
{children:f.element,value:{outlet:a,params:Object.freeze(Object.assign({},g,d)),pathname:[b,e].join("/").replace(/\/\/+/g,"/"),route:f}})},null)}
function G(a,b,c,d){c=void 0===c?"":c;d=void 0===d?!1:d;"string"===typeof b&&(b=parsePath(b));c=c.replace(/^\/+|\/+$/g,"");let e=b.pathname.slice(1);if(c)if(c===e)e="";else if(e.startsWith(c))e=e.slice(c.length).replace(/^\/+/,"");else return null;a=I(a);J(a);for(b=0;b<a.length;++b){let [g,f]=a[b];[c]=K(g,!0,d);if(c.test(e))return f.map((a,b)=>{b=f.slice(0,b+1).map(a=>a.path).join("/").replace(/\/\/+/g,"/");let [c,g]=K(b,!1,d);b=e.match(c);return{params:L(g,b.slice(2)),pathname:"/"+b[1],route:a}})}return null}
function I(a,b,c,d,e){b=void 0===b?[]:b;c=void 0===c?"":c;d=void 0===d?[]:d;e=void 0===e?[]:e;a.forEach((a,f)=>{let g=[c,a.path].join("/").replace(/\/\/+/g,"/"),m=d.concat(a);f=e.concat(f);b.push([g,m,f]);a.children&&I(a.children,b,g,m,f)});return b}let M=/^:\w+$/;function N(a){return a.split("/").reduce((a,c)=>a+(M.test(c)?2:"*"===c?-1:10),0)}function J(a){let b=a.reduce((a,b)=>{[b]=b;a[b]=N(b);return a},{});a.sort((a,d)=>{let [c,,g]=a;a=b[c];let [f,,h]=d;d=b[f];return a!==d?d-a:O(g,h)})}
function O(a,b){return a.length===b.length&&a.slice(0,-1).every((a,d)=>a===b[d])?a[a.length-1]-b[b.length-1]:0}function K(a,b,c){let d=[],e="^("+a.replace(/^\/+/,"").replace(/\*\//,"").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{d.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(e+="\\/?"),d.push("*"),e+="(.*)"):b&&(e+="\\/?");b&&(e+="$");return[new RegExp(e,c?void 0:"i"),d]}
function L(a,b){return a.reduce((a,d,e)=>{a[d]=b[e];return a},{})}function P(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}function E(a,b){b=void 0===b?"/":b;let {pathname:c,search:d="",hash:e=""}="string"===typeof a?parsePath(a):a;return{pathname:c?c.startsWith("/")?P(c,"/"):P(c,b):b,search:d,hash:e}}
function H(a,b){b=void 0===b?{}:b;return a.replace(/:(\w+)/g,(a,d)=>b[d]||`:${d}`).replace(/\*$/,a=>b[a]||a)}var MemoryRouter=p;var Navigate=r;var Outlet=u;var Redirect=w;var Route=x;var Router=q;var Routes=A;var createRoutesFromChildren=B;var generatePath=H;var matchRoutes=G;var resolveLocation=E;
var useBlocker=function(a,b){b=void 0===b?!0:b;let {history:c}=React.useContext(l);null==c?k(!1,"navigation blocking may be used only in the context of a <Router> component"):void 0;React.useEffect(()=>{if(b){let b=c.block(c=>{let d=Object.assign({},c,{retry(){b();c.retry()}});a(d)});return b}},[c,b,a])};var useHref=function(a){a=F(a);let {history:b}=React.useContext(l);null==b?k(!1,"href resolution may be used only in the context of a <Router> component"):void 0;return b.createHref(a)};
var useLocation=D;var useMatch=function(a){let b=D();a=F(a);return b.pathname===a.pathname};var useNavigate=t;var useOutlet=v;var useParams=function(){return React.useContext(n).params};var useResolvedLocation=F;var useRoutes=C;export{MemoryRouter,Navigate,Outlet,Redirect,Route,Router,Routes,createRoutesFromChildren,generatePath,matchRoutes,resolveLocation,useBlocker,useHref,useLocation,useMatch,useNavigate,useOutlet,useParams,useResolvedLocation,useRoutes};
//# sourceMappingURL=react-router.development.js.map
